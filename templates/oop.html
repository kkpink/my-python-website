{% extends "base.html" %}
{% block title %}Python's Building Blocks{% endblock %}

{% block content %}
<div class="content">
    <h2>Object-Oriented Programming in Python</h2>

    <!-- 4.1 – Object-Oriented Approach -->
    <h3>Understanding the Object-Oriented Approach</h3>
    <ul>
        <li><strong>Class:</strong> A blueprint for creating objects.</li>
        <li><strong>Object:</strong> An instance of a class.</li>
        <li><strong>Property:</strong> A variable attached to an object or class.</li>
        <li><strong>Method:</strong> A function inside a class.</li>
        <li><strong>Encapsulation:</strong> Hiding data inside objects to protect it.</li>
        <li><strong>Inheritance:</strong> A class (subclass) can inherit properties/methods from another (superclass).</li>
        <li><strong>Superclass:</strong> The parent class.</li>
        <li><strong>Subclass:</strong> The child class.</li>
        <li><strong>Identifying components:</strong> Use introspection to explore classes.</li>
    </ul>

    <!-- 4.2 – Properties -->
    <h3>Class and Object Properties</h3>
    <pre>
class MyClass:
    class_var = "I am shared"

    def __init__(self):
        self.instance_var = "I am unique"

obj = MyClass()
print(obj.__dict__)         # {'instance_var': 'I am unique'}
print(MyClass.__dict__)     # Shows class-level properties
    </pre>
    <ul>
        <li><strong>Instance variables:</strong> Belong to the object</li>
        <li><strong>Class variables:</strong> Shared across all instances</li>
        <li><strong>__dict__:</strong> Shows the internal attributes</li>
        <li><strong>Private members:</strong> Start with _ or __</li>
        <li><strong>Name mangling:</strong> Changes __var to _ClassName__var to avoid collisions</li>
    </ul>

    <!-- 4.3 – Methods -->
    <h3>Equipping Classes with Methods</h3>
    <pre>
class Greeter:
    def say_hello(self):
        print("Hello!")

g = Greeter()
g.say_hello()
    </pre>
    <ul>
        <li><strong>Methods:</strong> Functions defined in a class</li>
        <li><strong>self:</strong> Refers to the current instance</li>
    </ul>

    <!-- 4.4 – Class Structure -->
    <h3>Discovering Class Structure</h3>
    <ul>
        <li>hasattr(object, "name") – Checks if an attribute exists</li>
        <li>__name__ – Class name</li>
        <li>__module__ – Module name</li>
        <li>__bases__ – Tuple of parent classes</li>
    </ul>
    <pre>
class A: pass
class B(A): pass

print(B.__name__)    # 'B'
print(B.__bases__)   # (<class '__main__.A'>,)
    </pre>

    <!-- 4.5 – Inheritance and Hierarchy -->
    <h3>Building Class Hierarchies</h3>
    <pre>
class Animal:
    def speak(self):
        print("I make noise")

class Dog(Animal):
    def speak(self):
        print("Bark!")

a = Dog()
a.speak()  # Output: Bark!
print(isinstance(a, Animal))  # True
    </pre>
    <ul>
        <li>Single and Multiple Inheritance</li>
        <li>isinstance() checks object inheritance</li>
        <li><strong>Overriding:</strong> Redefining a method from a superclass</li>
        <li><strong>Polymorphism:</strong> Same method name, different behaviors across classes</li>
        <li><strong>__str__():</strong> Customize how objects print</li>
        <li><strong>Diamond Problem:</strong> Happens in multiple inheritance – Python uses MRO (Method Resolution Order)</li>
    </ul>

    <!-- 4.6 – Constructors -->
    <h3>Constructing and Initializing Objects</h3>
    <p>Use __init__ to run code when an object is created.</p>
    <pre>
class User:
    def __init__(self, name):
        self.name = name

u = User("Alice")
print(u.name)
    </pre>
    <ul>
        <li>__init__ is called automatically</li>
        <li>Can accept arguments to customize the object</li>
    </ul>
</div>
{% endblock %}
